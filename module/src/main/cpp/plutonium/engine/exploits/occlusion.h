namespace engine
{
    uintptr_t get_occlusion_function(uintptr_t typeinfo)
    {
        typedef void (*init_class_object_t)(void *);
        static auto init_class_object = (init_class_object_t) (_g_cheat.load()->_il2cpp->address() + offsets::GenerateTypeInfo1);
        uintptr_t get_instance_method = * reinterpret_cast<uintptr_t *> (_g_cheat.load()->_il2cpp->address() + offsets::get_instance_method);

        init_class_object(&typeinfo);
        init_class_object(&get_instance_method);

        uintptr_t func_instance = (uintptr_t) il2cpp::object::create<uintptr_t>((il2cpp::klass *) typeinfo);
        uintptr_t method_info = * (uintptr_t *) (_g_cheat.load()->_il2cpp->address() + offsets::method_info2);
        init_class_object(&method_info);

        static void *ctor = _g_cheat.load()->_itcu->find_method((il2cpp::klass *) typeinfo, ".ctor")->methodPointer;

        ((void (*)(uintptr_t, void*, uintptr_t)) ctor)(func_instance, nullptr, method_info);

        return func_instance;
    }

    axlebolt::occlusion_control* get_occlusion_control()
    {
        static il2cpp::klass *player_manager_klass                 = _g_cheat.load()->_itcu->find_class(nullptr, "OcclusionControl");
        static il2cpp::klass *lazy_singleton__player_manager_class = (il2cpp::klass *) player_manager_klass->_1.parent;

        static void *static_fields = lazy_singleton__player_manager_class->static_fields;

        return * (axlebolt::occlusion_control **) static_fields;
    }

    inline void set_ignore_raycasting()
    {
        axlebolt::occlusion_control *occlusion_control = get_occlusion_control();
        uintptr_t occlusion_func = * (uintptr_t *) ((uintptr_t) occlusion_control + 0x58);
        if (occlusion_func) { return; }

        uintptr_t func_objectocclude_bool = * (uintptr_t *) (_g_cheat.load()->_il2cpp->address() + offsets::func_objectocclude_bool);
        uintptr_t func_instance = get_occlusion_function(func_objectocclude_bool);

        occlusion_control->set_ignore_raycasting((void *) func_instance);
    }
}
